---
layout: post
author: choim7
title: "Moonjeog's finalProject_Wukong"
---

#finalProject_Wukong trinket link
<iframe src="https://trinket.io/embed/python/9d856e7438" width="100%" height="600" frameborder="0" marginwidth="0" marginheight="0" allowfullscreen></iframe>

I definitely have a lot to talk about regarding to this project. At first, I will briefly talk about how I came up with this game. So I decided to make a number 
guessing game because when I was learning Java myself last year, I noticed there was a guessing game that can be done with using random class and other useful
techniques. I then decided to make a game of which the core is to ask user to control the turtle to select the number randomly generated by the system because I 
think such interactive game which asks for both of the involvement of human and computer is very interesting! 

I set the context of the game as the Monkey King Wukong who's from Chinese fairy story should choose correct numbers to break the palace prison to get freedom. 
I chose Monkey King Wukong is because I'm Korean but I was born in China and I really admire such powerful character and thought it's very cool to make it 
a game. 

I've practiced a lot of skills and met a lot of problems when doing this project. So at first, I learned how to use PS to cut an image as an icon for my turtle
I also practiced how to initiate different modules regarding to there unique functions. For example, I initiated a Wukong class mainly to setup the turtle
controlled by the user, a Story class to write contexts,such as instructions, the main menu, scores, and game levels on the screen. I also initiated a generatorNumber
class which aims to generate a list of numbers by using width, number, and nRange parameters. Width means the width of the screen so that once it's divided by 
the length of the number list, we can know the distance between each number, so that we can draw them on the screen one by one and also we can know the xcor of 
the correct number generated by the system. Number means how many numbers we should let the user guess. And nRange means the range of the guessing numbers. 
For example, if we set the range into 100, then the numbers user need to guess are all within 100. I then want to use some code to show the methods that too me 
much time to think of, the methods that I think could be improved and other problems I still have. 

```ruby
#initiate win object to write win when user
#choose the correct number
win = Story()
#initiate score object to count and draw scores
score = Score()
#initiate a list that contains numbers of True(s)
#once the user hit the correct number
winList = []
#draw level 
writeLevel = Story()

#check if user hit the correct number 
#if not the screen will show not escaped
def checkIntersect():
  #set this gonext as False and once the user hit the right number
  #it will become True and if it's true, another method will be caleld
  #to enlarge the number list to increase the difficulty
  gonext = False
  if number.intersect(wukong) == True:
    wukong.goto(-150,-120)
    win.writeStory([10,-30],'You Win!',40,'bold','yellow')
    #add Trues to the winList the the len of the list indicates the scores
    winList.append('True')
    gonext = True
  #if hit other numbers, the screen will show not escaped
  elif number.intersect(wukong) == False:
    notEscaped()
  else:
    pass
  scoreNumber = winList.count('True')
  #update score
  score.scoreUpdate(scoreNumber)
  if gonext==True:
    start(scoreNumber)


```

I've definitely use most of my time in figuring out one problem I met here. So this method aims to check if the uer's turtle intersect with the correct 
number generated by the system. And if it intersects(pass the intersect method and this method will return a True), a True will be added to the list winList so that once I calculated how many Trues the list has, I can know how many scores the user get. The first problem is once it returns True, I will have the scores
updated by using Score class. I thought after it's updated, the updated score will be saved in self.score in the Score class so that I can use this self.score
attribute in my other methods, but the realty is, once I called self.score later, it didn't show any updates on the score. I actually wanted to use these updated
scores to trigger the number list to enlarge and increase the game level, but as the self.score didn't update, I failed to increase the game level by enlarging 
the number list. I also thought to setup a index = 0. And once the self.score updated and the winList updated, I can use: if len(winList) - index > 0, go to the next level, increase index by 1. This means that if the user hits the correct number, the list gets updated, the screen will go to the next level, the index will increase 1 and if the user didn't hit the correct number, for example, if the user if moving the turtle on the space of the screen, the len(winList) will keep the same will index=0, so the screen will remain the same and will not go to the next level. So the most important thing here is to have a updated winList or self.score. I thought global score can help me to get a timely updated score, but it seems it couldn't work. 

```
  #if number.intersect(wukong) == True:
    #diction = {'level':0,'index':0}
    #while diction['level'] < 2:
      #if (scoreNumber - diction['index']) > 0:
      #diction['level'] += 1
      #diction['index'] += 1
```
I originally put this code into the checkIntersect method. The problem is still, first, the scoreNumber won't get updated, the self.score won't get updated globally,and second, I setup a level as 0 and wanted to increase it. But no updates happened. So I tried to put the diction={} into different places. For example, I put it outside the method and use it as a parameter. But as the checkIntersect method also used in def go_forward, go_left etc, everytime the user moves, the system might have set the value of level and index into 0 again and again? This is just my guess. As I couldn't figure out the problems I met above, I tried to use another method to have my game update and increase levels. I set a boolean gonext = False at the beginning of the checkIntersect and if it passes the intersect method, the gonext will become True. And if True, it will call the level increase method. Since these code is within the checkIntersect method, I can immediately have the updated score and pass it to the method to increase the numberList. I had another problem in the code below.

```ruby

def start(scoreNumber):
  story.hide()
  number.clear()
  number.number += 1
  number.show()
  win.speed(30000)
  win.hide()

```

So this code follows the checkIntersect method and it aims to increase the list number and also hide the win character printed after user chose the correct number. I aimed to make a scenerio that once the user hit the correct number, the screen will show 'win!' and after 5 seconds, the next level screen shows. But once I chose to hide the win, it only appears about 1 second after the user hit the correct number and go to the next level. I didn't know how to slow it down. I thought I could slow it down by increase the value of speed, but it didn't work. 

Another problem in this game is I don't really know how to use while loop to increase the level, so I just ask the system to stop running once the user gets to the level 4 which has 5 numbers in the number list. I also don't know how to check if the user hit the wrong answer. I uesd a very very dumb method, which is below:
```ruby
     #calculated the distance between each number in the list
      distance=int(self.width / ((self.number) + 1))
      
      #distance = self.width / (len(numList))
      
      #calculated the xcor of the correct number
      xCorrectNum = -self.width / 2 + (self.index + 1) * distance
      self.write(xCorrectNum, font=('Times New Roman',60))
      #self.write('aaaaa',font=('Times New Roman',20))
      x=object.xcor()
      y=object.ycor()
      
      #calculated the scale of the correctnumber 
      xbounds = (xCorrectNum - self.radius, xCorrectNum + 2 * self.radius)
      check_x = x > min(xbounds) and x < max(xbounds)
      check_y = y > 30 
      #first  = (x == xCorrectNum)
      #second = (y == 50)
      
      #calculated the scale of other numbers 
      p1 = (xCorrectNum - 3 * distance - self.radius,xCorrectNum - 3 * distance + 2 * self.radius)
      p2 = (xCorrectNum - 2 * distance - self.radius,xCorrectNum - 2 * distance + 2 * self.radius)
      p3 = (xCorrectNum - 1 * distance - self.radius,xCorrectNum - 1 * distance + 2 * self.radius)
      p4 = (xCorrectNum + 1 * distance - self.radius,xCorrectNum + 1 * distance + 2 * self.radius)
      p5 = (xCorrectNum + 2 * distance - self.radius,xCorrectNum + 2 * distance + 2 * self.radius)
      p6 = (xCorrectNum + 3 * distance - self.radius,xCorrectNum + 3 * distance + 2 * self.radius)
      
      #setup booleans for other numbers other than the correct one
      checkp1 = x > min(p1) and x < max(p1)
      checkp2 = x > min(p2) and x < max(p2)
      checkp3 = x > min(p3) and x < max(p3)
      checkp4 = x > min(p4) and x < max(p4)
      checkp5 = x > min(p5) and x < max(p5)
      checkp6 = x > min(p6) and x < max(p6)
      
      #put the bools into a dictionary
      pt={'p1': checkp1,'p2':checkp2,'p3':checkp3,'p4':checkp4,'p5':checkp5,'p6':checkp6 }
      
      #if the user's turtle hits the scale of the correct number, will return True
      if (check_x and check_y):
        return True
      #or if hits the scale of other numbers, will return False
      elif((pt['p1'] or pt['p2'] or pt['p3'] or pt['p4'] or pt['p5'] or pt['p6']) and y > 30):
        return False
      #elif(x<0 and y<0):
        #return False
      else:
        pass
```
So I used this code to check the scale of the correct and incorrect numbers and see if the user has hit on them. I first calculated the distance between each number by using the width of the screen and the len(winList). I learned the skills of calculating the xbounds from the video our Professor gave by adding/minusing radius to/from xcor. I didn't really know how to calculate the scale of incorrect numbers. So I thought, if there are 3 numbers to guess, and if the correct number is in the middle, then the xcor for other 2 is the xcor of the correct number minus 1 distance or plus 1 distance from it. If the correct number is in the right, then the other 2 is 2 distance and 1 distance from it(so it should minus the distance). So if the max number I set for the list is 5, then if the correct number is in the right, there will be 4 distance between it and the one on the left side. So I set 6 points with different distance and if the user hit the xcor of these 6 points, the system will shows wrong number. This method is pretty redundant, but I couldn't think of a better method. There was another problem I met in this part. So before I added the radius to the xcor of these numbers, even if the user's turtle goes to that position, nothings showed up. But once I added radius to them, the system reacted well. I don't really understand the part to setup the levels in the video as well and I don't really understad using playing = True, while playing: etc to manage the relationship between the mainloop and other methods in the code. So maybe I need more practice and search on these methods so that I won’t get confused with why my attribute self.score doesn’t get updated or if I have made mistakes between using local variables and global variables. All in all, I really learned a lot from the video professor Hauser has gave and I did practice the list, dictionary, tuples(though I didn’t use it in my code, I met a problem when using tuples and then went to do more research on it), for loop, while loop, modules, etc. Finally, I really appreciate the patience Professor Hauser and Misha gave, it was a really good opportunity to practice the coding skills!
